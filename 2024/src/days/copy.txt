import assert from "assert"
import * as fs from "fs"

// -----------------------------------------------------------------------------
// TYPES
// -----------------------------------------------------------------------------

type Data = string[][]

// -----------------------------------------------------------------------------
// PRIVATE
// -----------------------------------------------------------------------------

function parseInput(path: string): Data {
  return fs
    .readFileSync(path, "utf-8")
    .trimEnd()
    .split("\n")
    .map((line) => line.split(""))
}

// prettier-ignore
const NUMBERIC_KEYPAD = [
    ["7", "8", "9"],
    ["4", "5", "6"],
    ["1", "2", "3"],
    ["" , "0", "A"]
  ]

const NUMBERIC_MAP = {
  "7": [0, 0],
  "8": [0, 1],
  "9": [0, 2],
  "4": [1, 0],
  "5": [1, 1],
  "6": [1, 2],
  "1": [2, 0],
  "2": [2, 1],
  "3": [2, 2],
  "0": [3, 1],
  A: [3, 2]
}

// prettier-ignore
const DIRECTION_KEYPAD = [
    ["" , "^", "A"],
    ["<", "v", ">"],
  ]

const DIRECTION_MAP = {
  "^": [0, 1],
  "<": [1, 0],
  v: [1, 1],
  ">": [1, 2],
  A: [0, 2]
}

function manhattanDistance(a: number[], b: number[]) {
  return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1])
}

function shortestPaths(keypad: string[][], map: Record<string, number[]>) {
  const paths = new Map<string, Map<string, string[][]>>()
  for (const from of Object.keys(map)) {
    if (from === "") continue
    paths.set(from, new Map())
    for (const to of Object.keys(map)) {
      if (from === to) continue
      const pathLimit = manhattanDistance(map[from], map[to])
      const start = map[from]
      const queue = [{ pos: start, path: [] }]
      while (queue.length > 0) {
        let { pos, path } = queue.shift()

        if (path.length > pathLimit) continue

        const [x, y] = pos
        if (x < 0 || y < 0 || x >= keypad.length || y >= keypad[0].length) continue

        const cell = keypad[x][y]
        if (cell === "") continue

        if (cell === to.toString()) {
          if (!paths.get(from).has(to)) paths.get(from).set(to, [path])
          else paths.get(from).get(to).push(path)
          continue
        }

        queue.push({ pos: [x - 1, y], path: [...path, "^"] })
        queue.push({ pos: [x + 1, y], path: [...path, "v"] })
        queue.push({ pos: [x, y - 1], path: [...path, "<"] })
        queue.push({ pos: [x, y + 1], path: [...path, ">"] })
      }
    }
  }

  return paths
}



const r3Cache = new Map<string, string[]>()
function calcR3Paths(r2Path: string[], directionPaths: Map<string, Map<string, string[][]>>) {
  if (r3Cache.has(r2Path.join(""))) return r3Cache.get(r2Path.join(""))

  const paths = []
  const queue = [{ from: "A", current: r2Path[0], remaining: r2Path.slice(1), path: 0 }]
  while (queue.length) {
    let { from, current, remaining, path } = queue.shift()

    if (!current) {
      paths.push(path)
      continue
    }

    const nextCurrent = remaining[0]
    const nextRemaining = remaining.slice(1)
    if (from === current) {
      queue.push({ from, current: nextCurrent, remaining: nextRemaining, path: path + 1 })
    } else {
      for (const r2Path of directionPaths.get(from).get(current)) {
        const nextFrom = current
        queue.push({ from: nextFrom, current: nextCurrent, remaining: nextRemaining, path: path + r2Path.length + 1 })
      }
    }
  }

  r3Cache.set(r2Path.join(""), paths)

  return paths
}

const r2Cache = new Map<string, string[]>()
function calcR2Paths(r1Path: string[], directionPaths: Map<string, Map<string, string[][]>>) {
  if (r2Cache.has(r1Path.join(""))) return r2Cache.get(r1Path.join(""))

  const paths = []
  const queue = [{ from: "A", current: r1Path[0], remaining: r1Path.slice(1), path: 0 }]
  while (queue.length) {
    let { from, current, remaining, path } = queue.shift()

    if (!current) {
      paths.push(path)
      continue
    }

    const nextCurrent = remaining[0]
    const nextRemaining = remaining.slice(1)
    if (from === current) {
      queue.push({ from, current: nextCurrent, remaining: nextRemaining, path: path + 1 })
    } else {
      for (const r2Path of directionPaths.get(from).get(current)) {
        const nextFrom = current
        const nextPaths = calcR3Paths([...r2Path, "A"], directionPaths)
        for (const nextPath of nextPaths) {
          queue.push({ from: nextFrom, current: nextCurrent, remaining: nextRemaining, path: path + nextPath })
        }
      }
    }
  }

  r2Cache.set(r1Path.join(""), paths)

  return paths
}

function part1(data: Data) {
  let count = 0
  const numericPaths = shortestPaths(NUMBERIC_KEYPAD, NUMBERIC_MAP)
  const directionPaths = shortestPaths(DIRECTION_KEYPAD, DIRECTION_MAP)

  for (const code of data) {
    console.log(code)
    // prettier-ignore
    const numbers = Number(code.map((digit) => Number(digit)).filter((digit) => !isNaN(digit)).join(""))
    const paths = []
    const queue = [{ from: "A", current: code[0], remaining: code.slice(1), path: 0 }]
    while (queue.length) {
      let { from, current, remaining, path } = queue.shift()

      if (!current) {
        paths.push(path)
        continue
      }

      for (const r1Path of numericPaths.get(from).get(current)) {
        const nextFrom = current
        const nextCurrent = remaining[0]
        const nextRemaining = remaining.slice(1)
        const nextPaths = calcR2Paths([...r1Path, "A"], directionPaths)
        for (const nextPath of nextPaths) {
          queue.push({ from: nextFrom, current: nextCurrent, remaining: nextRemaining, path: path + nextPath })
        }
      }
    }

    count += paths.toSorted((a, b) => a - b)[0] * numbers
  }

  return count
}

function part2(data: Data) {
  return 0
}

// -----------------------------------------------------------------------------
// EXPORTS
// -----------------------------------------------------------------------------

const inputPath = "./src/inputs/d21.txt"
const inputTestPath1 = "./src/inputs/d21-t1.txt"

export function runPart1() {
  console.log("Test 1: ", part1(parseInput(inputTestPath1)))
  assert(part1(parseInput(inputTestPath1)) === 126384)

  console.time("Time")
  console.log("Part 1: ", part1(parseInput(inputPath)))
  console.timeEnd("Time")
}

export function runPart2() {
  console.log("Test 2: ", part2(parseInput(inputTestPath1)))
  assert(part2(parseInput(inputTestPath1)) === undefined)

  console.time("Time")
  console.log("Part 2: ", part2(parseInput(inputPath)))
  console.timeEnd("Time")
}
